## 実行

実行したいバージョンのディレクトリ直下で以下を打ってください

```
./calc
```

※ calc は実行ファイルなのでコンパイル不要です

## プログラムの解説

lex と yacc を使っています。
lex はパーサーと呼ばれるもので、入力された文字列をトークンに分割します。
yacc は構文解析器と呼ばれるもので、トークンを元に構文解析を行います。

lex は .l という拡張子を使います。
lex では、ある記号がどういう意味を持つかを定義します。
例えば、'+' が足し算を意味するとか、'-' が引き算を意味するとかです。
何が文字列なのか、何が数字なのかも定義します。

yacc は .y という拡張子を使います。
yacc では、lex で定義した記号を使って、どういう構文を持つかを定義します。
例えば、数字の後に '+' が来て、その後に数字が来たら、足し算をするとかです。

最初はこんな感じの理解で十分です。

難しいと思いますが、ざっくりと lex は「'+' は足し算するための記号だよ」とコンピューターに教えてあげる役割、yacc は「数字、足し算する記号、数字が連続したら足し算するんだよ」とコンピューターに教えてあげる役割です。
とても誤解を招く表現なので詳しくは各自勉強してください。

いまここでは lex は「その文字が何を表すか」がわかって、yacc は「足し算などの計算ができる」という理解でかまいません。

### lex ファイルの解説

まずはコードを見てみましょう。
（わからなくて大丈夫です！）

```calc.l
%{
#include "calc.tab.h" // yacc で生成されるファイルを読み込むための記述
%}

%option noyywrap

%%

[0-9]+  { yylval = atoi(yytext); return NUMBER; } // 数字を読み込んだら、その値をyylvalにセットしてNUMBERを返す
[+]     { return PLUS; } // +を読み込んだら、PLUSを返す。これは '+' が足し算であることを示すための記述
\n      { return EOL; } // 行末に来たら、EOLを返す。EOLは行末を示すための記述
.       { /* 無視する文字。ピリオドなので、改行以外のすべての文字を無視する */ }

%%
```

ここで重要な記述は `%%` に挟まれている部分です。
```
[0-9]+  { yylval = atoi(yytext); return NUMBER; } // 数字を読み込んだら、その値をyylvalにセットしてNUMBERを返す
[+]     { return PLUS; } // +を読み込んだら、PLUSを返す。これは '+' が足し算であることを示すための記述
\n      { return EOL; } // 行末に来たら、EOLを返す。EOLは行末を示すための記述
.       { /* 無視する文字。ピリオドなので、改行以外のすべての文字を無視する */ }
```

まず、`[0-9]+  { yylval = atoi(yytext); return NUMBER; }` ここの記述から見ていきます。
この記述部分では、

calc.l は lex 用のファイルで、calc.y は yacc 用のファイルです。




## コンパイル

コンパイルを試してみたい方はやってみてください

### 環境構築

コンパイルには flex(lex) と bison(yacc) を使います。

flex と bison のインストール
```
brew install flex bison
```

インストールした後に以下の手順でコンパイルできます

```
flex calc.l
bison -d calc.y
gcc gcc lex.yy.c calc.tab.c -o calc
```
